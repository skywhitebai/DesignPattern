通过这些模式让你找到“封装变化”、“对象间松散耦合”、“针对接口编程”的感觉，从而设计出易维护、易扩展、易复用、灵活性好的程序。


面向对象的好处：
通过封装、继承、多态把程序的耦合度降低,高内聚，低耦合
用设计模式使得程序更加的灵活、容易修改，并且易于复用

简单工厂模式：
简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具
体产品的依赖。
不过如果要添加新的逻辑就要修改工厂类，违背了开放-封闭原则。

策略模式：
面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类
策略模式strategy：它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
策略模式是一种定义一系列算法的方法，从概念上讲，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用
所有的算法，减少了各种算法类与使用算法类之间的耦合。
策略模式的strategy类层次为context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。
策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。
策略模式就是用来封装算法的，但是在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间
应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
自我理解：例如促销模式修改，只需要添加新的促销策略即可，不需要修改以前的代码，达到解耦和可扩展

单一职责原则：SRP
单一职责原则，就一个类而言，应该仅有一个引起它变化的原因。
如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦
合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。
软件设计真正要做的许多内容，就是发现职责并把那些职责互相分离。
如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。
代码要易维护、易扩展、易复用、灵活多样。

开放-封闭原则：
开放-封闭原则，是说软件实体（类、模块、函数等等），应该可以扩展，但是不可修改。
对于扩展是开放的，对于修改是封闭的。
面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有代码。
开放-封闭原则是面向对象的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活
性好。开发人员应该仅对程序中呈现出频繁变化的那部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个
好主意。拒绝不成熟的抽象和抽象本身一样重要。

依赖倒转原则：
依赖倒转原则，抽象不应该依赖细节，细节应该依赖抽象。针对接口编程，不要针对实现编程。
依赖倒转原则：
A.高层模块不应该依赖底层模块。两个都应该依赖抽象。
B.抽象不应该依赖细节，细节应该依赖抽象

里氏替换原则：
一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且觉察不出父类对像和子类对象的区别。也就是说，在软件里面，
把父类都替换成它的子类，程序的行为没有变化。
里氏替换原则：子类型必须能替换掉它的父类型。
只有当子类可以替换掉父类，软件单位的功能不受影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。
由于有里氏替换原则，才使得开放-封闭原则成为了可能。
由于子类型的可替换性才使得使用父类类型的模块在无需修改的情况下就可以扩展。
依赖倒转其实可以说是面向对象设计的标志，用那种语言编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，
即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。

P62
装饰模式：
装饰模式（Decorator），动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。
装饰模式是利用SetComponent来对对象进行包装的，每个装饰对象的实现和如何使用这个对象分离开，每个装饰对象只关心自己的功能，
不需要关心如何被添加到对象链当中。
装饰模式是为已有功能动态地添加更多功能的一种方式。
装饰模式把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以运行
时根据需要选择地、按顺序的使用装饰功能包装对象。
装饰模式的优点，把类中的装饰功能从类中搬移去除，这样可以简化原来的类。
有效地把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的装饰逻辑。

代理模式:
代理模式(Proxy):为其他对象提供一种代理以控制对这个对象的访问。
代理模式的应用：
第一，远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在不同地址空间的事实。
第二，虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。
第三，安全代理，用来控制真实对象访问时的权限。
第四，智能指引，是指当调用真实的对象时，代理处理另外一些事。

P66
工厂方法模式：
工厂方法模式（Factory method），定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。
工厂方法模式实现时，客户端需要决定实例化那一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑
判断移到了客户端代码来进行。你想要添加功能，本来是改工厂类的，而现在是修改客户端！

P95
原型模式：
原型模式（Prototype），用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。
一般在初始化的信息不发生变化的情况下，克隆是最好的办法，这既隐藏了对象创建的细节，又对性能是大大的提高。

P108
模板方法模式：
当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理。
模板方法模式，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
模板方法模式是通过把不变形为搬移到超类，去除子类中的重复代码体现它的优势。
模板方法模式就是提供了一个很好的代码复用平台。

P120
迪米特法则：
迪米特法则也叫最少知识原则。
迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者
转发这个调用。
迪米特法则其根本思想，是强调了类之间的松耦合。类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。

P121
外观模式：
外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
何时使用外观模式：
首先，在设计初期阶段，应该要有意识的将不同的两个层分离，层与层之间建立外观Facade。
其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂。
增加外观Facade可以提供一个简单的接口，减少它们之间的依赖。
第三，在维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展，为新系统开发一个外观（Facade）类，来提供设计粗糙或高复杂的遗留代码的
比较清晰简单的接口，让新系统与Facade对象交互，Facade与遗留代码交互所有复杂的工作。

P130
建造者模式：
依赖倒转原则？抽象不应该依赖细节，细节应该依赖于抽象
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
如果我们使用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体的建造的过程和细节就不需要知道了。
建造者模式（Builder），将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方法时适用的模式。

P140
观察者模式：
观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够
自动更新自己。
观察者模式所做的工作其实就是在接触耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使各自的变化都不会影响另一边的变化。

P159
抽象工厂模式：
菜鸟程序员碰到问题，只会用时间来摆平，所以即使整天加班，老板也不想给菜鸟加工资，原因就在于此。
工厂方法模式是定义一个用于创建对象的接口，让子类决定实例化那一个类.
抽象工厂模式（Abstract Factory），提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。
抽象工厂的优缺点：
好处便是易于交换产品系列，由于具体工厂类，在一个应用中只需要初始化的时候出现一次，这就使得改变一个应用的具体工厂变得非常容易，它只需要改变具
体工厂即可使用不同的产品配置。
它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中。
所有在用简单工厂的地方，都可以考虑用反射技术来去除switch或if，解除分支判断带来的耦合。
一个程序员如果从来没有熬夜写程序的经历，不能算是一个好程序员，因为他没有痴迷过，所有他不会有大成就。

P174
状态模式：
状态模式（State），当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的逻辑判断简化。

P189
适配器模式：
适配器模式（Adapter），将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
系统的数据和行为都正确，但接口不符时，我们应该考虑用适配器，目的是控制范围之外的一个原有对象与某个接口匹配。适配器模式主要应用于希望复用一些现
存的类，但是接口又与复用环境要求不一致的情况。
类适配器模式和对象适配器模式。
使用一个已经存在的类，但如果它的接口，也就是它的方法和你的要求不相同时，就应该考虑用适配器模式。
两个类所做的事情相同或者相似，但具有不同的接口时要使用适配器。
客户代码可以统一调用同一个接口，可以更简单、更直接、更紧凑。
在双方都不容易修改的时候要考虑使用适配器模式适配。

P198
备忘录模式：

